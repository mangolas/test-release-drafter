#!/usr/bin/env bash

set -eo pipefail

# Tools for managing draft, prerelease and actual Github release data

source .github/scripts/tag-search
fetch_latest_tag_names

_promote_draft_to_prerelease() {
  echo "Promote draft '$LATEST_DRAFT_TAG' to release candidate ..."
  old_changelog=$(hub release show -f '%b' $LATEST_DRAFT_TAG)

  hub release edit --draft=false --prerelease=true \
    -m "$LATEST_DRAFT_TAG (rc)" -m "$old_changelog" "$LATEST_DRAFT_TAG"
}

_merge_draft_to_prerelease() {
  echo "Merge draft '$LATEST_DRAFT_TAG' to '$LATEST_PREREL_TAG' ..."
  draft_changelog=$(hub release show -f '%b' $LATEST_DRAFT_TAG)

  changelog_addition=(
    $'\n'
    "> Changelog from merged draft release '$LATEST_DRAFT_TAG'. Manual edit needed!"
    $'\n'
    "$draft_changelog"
  )
  # XXX(lassi) We have to create new prerelease on dev merge, as the release's
  # *published_at* is only set when release is created. And 'release-drafter'
  # Github action is using that time stamp to check what is changed in dev until
  # that time. So we must be extra careful that dev pr changes are not lost in
  # regard automatic changelog manipulation. It would be better if changes would
  # just be calculated between last_release_tag..dev, but unfortunately
  # that is not the case.
  _change_prerelease create "${changelog_addition[*]}"
  echo "Deleting merged '$LATEST_DRAFT_TAG' draft release ..."
  hub release delete "$LATEST_DRAFT_TAG"
}

_change_prerelease() {
  # 'create' or 'edit'
  local change_method=$1
  local additional_msg=${2:-}

  echo "Advancing tag '$LATEST_PREREL_TAG' to rc HEAD ..."
  git tag -f "$LATEST_PREREL_TAG"
  git push -f origin "$LATEST_PREREL_TAG"

  old_changelog=$(hub release show -f '%b' $LATEST_PREREL_TAG)
  if [[ $change_method == 'create' ]]; then

    echo "Deleting previous prerelease '$LATEST_PREREL_TAG' ..."
    hub release delete "$LATEST_PREREL_TAG"

    echo "Creating updated prerelease '$LATEST_PREREL_TAG' ..."
    hub release create --prerelease=true \
      -m "$LATEST_PREREL_TAG (rc)" -m "$old_changelog" -m "$additional_msg" \
      "$LATEST_PREREL_TAG"
  else
    echo "Editing prerelease '$LATEST_PREREL_TAG' ..."
    hub release edit --prerelease=true \
      -m "$LATEST_PREREL_TAG (rc)" -m "$old_changelog" -m "$additional_msg" \
      "$LATEST_PREREL_TAG"
  fi
}

_promote_prerelease_to_release() {
  local release_tag=${LATEST_PREREL_TAG/-rc*/}
  echo "Creating a release '$release_tag' from '$LATEST_PREREL_TAG' ..."
  old_changelog=$(hub release show -f '%b' $LATEST_PREREL_TAG)

  hub release create -m "$release_tag" -m "$old_changelog" "$release_tag"
  echo "Deleting released prerelease '$LATEST_PREREL_TAG' ..."
  hub release delete "$LATEST_PREREL_TAG"
}

_is_last_change_from_dev() {
  local version=$1
  # XXX(lassi) I'm sure there can be better ways to detect when dev is merged
  # to rc in a way that draft release contents should/can be moved to prerelease.
  #
  # This could also be out of sync if dev changes are pushed while this is running,
  # but that should be rare. And in worst case changelog is missing something
  # that has to be manually added later.
  git log -n 1 | \
  grep -C 20 "Merge pull request" | \
  grep -C 20 "/dev" | \
  grep "$version"
}

update_prerelease() {
  if [[ -z $LATEST_DRAFT_TAG && -z $LATEST_PREREL_TAG ]]; then
    echo "Could not find either draft or prerelease status Github release! Can't do anything sane."
  elif [[ -z $LATEST_PREREL_TAG ]]; then
    _promote_draft_to_prerelease
  else
    if _is_last_change_from_dev "$LATEST_DRAFT_TAG"; then
      _merge_draft_to_prerelease
    else
      echo "Updating prerelease from change directly to rc branch ..."
      _change_prerelease edit \
        $'\n> Rc was changed from non dev-branch merge, remember to update changelog manually!\n'
    fi
  fi
}

release_new_version() {
  if [[ -z $LATEST_PREREL_TAG ]]; then
    echo "ERROR: Could not find rc Github release! Can't proceed with release!"
    exit 1
  else
    _promote_prerelease_to_release
  fi
}

"$@"
